# address in decimal.
0007 079B # LDR mem(127) to r(3), holds number 20 aka i
0008 C600 # IN devid(0) to r(2), holds first word entered from user
0009 0B9B # STR r(3) to mem(127), pushes current i back to mem, starts at 20
000A 0599 # LDR mem(125) to R1, reintialize R1 to be 121, which will be used to compute EA = 121 - i
000B 159B # SMR R1 - mem(127) to R1, R1 = 121, subtract current i held in mem(127), this is the EA
000C 0997 # STR R1 to mem(123), EA for current number 
000D 0AB7 # STR R2 to mem(mem(123)), use EA held in mem[123] to store number popped from device
000E 3B08 # SOB R3 go to 08, subtract 1 from R3, which now is 19, then go to address 08
000F C600 # IN devid(0) to r(2), reads in target places in R2
0010 0A96 # STR R2 to mem(122), store target in mem[122]
0011 0780 # LDR mem(100) to R3, reintiilize i to be 20, stored in mem[100]
0012 0B80 # STR R3 to mem(100), store current value of i
0013 0696 # LDR mem(122) to R2, load target value to R2
0014 0599 # LDR mem(125) to R1, load 121 to R1
0015 1580 # SMR R1 - mem(100) to R1 #get EA = 121 - current i
0016 0997 # STR R1 to mem(123), store EA into mem[123]
0017 16B7 # SMR R2 - mem(mem(123)), use EA to get word
0018 291A # JCC to 26##, JCC to 001A if satisfied (based off of prior arthemtic instruction)
0019 2C1C # JMA to 28##, if invalid go to 001C, why? 
001A 06B7 # LDR mem(mem(123)) to R2 ##26, use EA to get value 
001B 1696 # SMR R2 - mem(122) to R2, compare with target value 
001C 0A9A # STR R2 to mem(126) ##28, stores difference
001D 1698 # SMR R2 - mem(124), take difference and subtract from FFFF (max value) stored in mem[124]
001E 2956 # JCC to 32##, if smaller than current min (in 124), then jump to 0020
001F 2C5A # JMA to 36##, if not smaller then jump to 0024
0020 069A # LDR mem(126) to R2 ##32, load difference to R2
0021 0A98 # STR R2 to mem(124), store difference into new min at mem[124]
0022 06B7 # LDR mem(mem(123)) to R2, get value that made the new smallest difference
0023 0A95 # STR R2 to mem(121), store the value that made the smallest difference into result located in mem[121]
0024 3B12 # SOB R3 go to 12  ##36, decrement i, so long as its valid go back up to 0012
0025 0495 # LDR mem(121) to R0, if invalid, then we're done comparing at load reuslt into R0
0026 C801 # OUT output r(0) to devid(1), output results
0064 0014
007C FFFF
007D 0079, # 121
007F 0014, 20